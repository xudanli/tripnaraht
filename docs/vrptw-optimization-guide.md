# VRPTW (带时间窗的车辆路径问题) 优化指南

## 概述

VRPTW (Vehicle Routing Problem with Time Windows) 是传统 TSP 算法的增强版本，专门解决旅行规划中的时间窗约束问题。

### 核心痛点

传统的 TSP 算法（如高德/百度的多点路线规划）通常只求"路程最短"。但在旅行中，"不走回头路"不如"到了门刚好开"重要。

**问题示例**：
- ❌ 早上 8 点去 10 点才开门的商场
- ❌ 下午 1 点赶到 2 点就要关门的午市餐厅

### VRPTW 解决方案

VRPTW 在标准路径规划上增加了两个硬约束：

1. **Time Windows (时间窗)**：地点 $i$ 必须在 $[a_i, b_i]$ 时间段内访问
   - 例如：餐厅午市 11:30 - 14:00
   - 例如：商场营业时间 09:00 - 22:00

2. **Service Time (服务时长)**：在地点 $i$ 必须停留 $s_i$ 时间
   - 例如：游玩 2 小时
   - 例如：用餐 1.5 小时

## 输入数据结构

### JSON 格式

```json
{
  "locations": [
    { 
      "id": 0, 
      "name": "酒店(起点)", 
      "window": ["2024-05-01T08:00:00+09:00", "2024-05-01T09:00:00+09:00"], 
      "duration": 0 
    },
    { 
      "id": 1, 
      "name": "东京塔", 
      "window": ["2024-05-01T09:00:00+09:00", "2024-05-01T22:00:00+09:00"], 
      "duration": 120 
    },
    { 
      "id": 2, 
      "name": "筑地市场", 
      "window": ["2024-05-01T05:00:00+09:00", "2024-05-01T14:00:00+09:00"], 
      "duration": 90 
    }
  ],
  "time_matrix": [
    [0, 15, 20],  // 从酒店到各点的时间(分钟)
    [15, 0, 25],  // 从东京塔到各点的时间
    [20, 25, 0]   // 从筑地市场到各点的时间
  ]
}
```

### 字段说明

- **locations**: 地点列表
  - `id`: 地点索引（从 0 开始）
  - `name`: 地点名称
  - `window`: 时间窗 `[最早到达时间, 最晚到达时间]` (ISO 8601 datetime)
  - `duration`: 服务时长（分钟）

- **time_matrix**: 时间矩阵 (N×N)
  - `time_matrix[i][j]`: 从地点 $i$ 到地点 $j$ 的旅行时间（分钟）
  - 必须通过地图 API 预先获取

## API 使用

### 启用 VRPTW 优化

在路线优化请求中设置 `useVRPTW: true`：

```json
{
  "placeIds": [1, 2, 3, 4, 5],
  "config": {
    "date": "2024-05-01",
    "startTime": "2024-05-01T08:00:00+09:00",
    "endTime": "2024-05-01T18:00:00+09:00",
    "pacingFactor": 1.0,
    "useVRPTW": true
  }
}
```

### 为地点设置时间窗

在创建或更新地点时，可以设置时间窗约束：

```json
{
  "id": 1,
  "name": "东京塔",
  "timeWindow": {
    "earliest": "2024-05-01T09:00:00+09:00",
    "latest": "2024-05-01T22:00:00+09:00"
  },
  "serviceTime": 120
}
```

## 算法实现

### 算法流程

1. **贪心构造初始解**
   - 从起点开始
   - 每次选择时间窗最早且可达的下一个地点
   - 如果无法满足时间窗，跳过该地点

2. **局部搜索优化 (2-opt)**
   - 尝试交换路线中的两个片段
   - 如果改善且满足约束，接受新解

3. **时间窗约束验证**
   - 计算每个地点的到达时间
   - 检查是否在时间窗内
   - 如果早到，等待到最早时间
   - 如果晚到，记录违反约束

### 约束检查

对于每个地点 $i$：

1. 计算到达时间：$arrival_i = departure_{i-1} + travel_{i-1,i}$
2. 如果 $arrival_i < earliest_i$，等待：$arrival_i = earliest_i$
3. 如果 $arrival_i > latest_i$，违反约束（记录警告）
4. 计算离开时间：$departure_i = arrival_i + service_i$

## 输出结果

### 成功案例

```json
{
  "route": [0, 2, 1],
  "arrivalTimes": [
    "2024-05-01T08:00:00+09:00",
    "2024-05-01T08:20:00+09:00",
    "2024-05-01T10:05:00+09:00"
  ],
  "departureTimes": [
    "2024-05-01T08:00:00+09:00",
    "2024-05-01T09:50:00+09:00",
    "2024-05-01T12:05:00+09:00"
  ],
  "feasible": true
}
```

### 违反约束案例

```json
{
  "route": [0, 1, 2],
  "arrivalTimes": [
    "2024-05-01T08:00:00+09:00",
    "2024-05-01T08:15:00+09:00",
    "2024-05-01T14:30:00+09:00"
  ],
  "departureTimes": [
    "2024-05-01T08:00:00+09:00",
    "2024-05-01T10:15:00+09:00",
    "2024-05-01T16:00:00+09:00"
  ],
  "feasible": false,
  "violations": [
    {
      "locationId": 2,
      "locationName": "筑地市场",
      "expectedWindow": [
        "2024-05-01T05:00:00+09:00",
        "2024-05-01T14:00:00+09:00"
      ],
      "actualArrival": "2024-05-01T14:30:00+09:00",
      "violationType": "LATE"
    }
  ]
}
```

## 最佳实践

### 1. 时间矩阵预计算

时间矩阵必须通过地图 API 预先获取，不能使用简单距离估算：

```typescript
// ✅ 正确：使用真实交通时间
const timeMatrix = await precomputeTimeMatrix(places, travelMode);

// ❌ 错误：使用距离估算
const timeMatrix = calculateDistanceMatrix(places);
```

### 2. 时间窗设置

- **餐厅**：设置用餐时间窗（如午市 11:30-14:00）
- **景点**：设置营业时间窗（如 09:00-22:00）
- **特殊活动**：设置活动时间窗（如演出 19:00-21:00）

### 3. 服务时长设置

- **景点**：根据游玩时间设置（如 2 小时）
- **餐厅**：根据用餐时间设置（如 1.5 小时）
- **购物**：根据购物时间设置（如 1 小时）

### 4. 起点设置

通常将酒店设为起点（索引 0），并设置出发时间窗：

```json
{
  "id": 0,
  "name": "酒店",
  "window": ["2024-05-01T08:00:00+09:00", "2024-05-01T09:00:00+09:00"],
  "duration": 0
}
```

## 性能考虑

### 时间复杂度

- **贪心构造**：$O(n^2)$
- **局部搜索**：$O(n^2 \times iterations)$
- **总体**：$O(n^2 \times iterations)$

对于 $n \leq 50$ 的地点，算法通常在 1 秒内完成。

### 优化建议

1. **限制地点数量**：如果地点过多（>50），先进行空间聚类
2. **缓存时间矩阵**：避免重复计算相同点对的时间
3. **并行计算**：时间矩阵计算可以并行进行

## 故障排查

### 问题：所有路线都违反时间窗约束

**原因**：
- 时间窗设置不合理（如太短）
- 旅行时间估算不准确
- 服务时长设置过长

**解决**：
1. 检查时间窗是否合理
2. 使用真实交通时间（而非距离估算）
3. 调整服务时长

### 问题：算法无法找到可行解

**原因**：
- 时间窗冲突（如两个地点的时间窗完全不重叠）
- 旅行时间过长，无法在时间窗内到达

**解决**：
1. 放宽时间窗约束
2. 减少地点数量
3. 增加总时间预算

## 相关文档

- [路线优化 API 文档](./API-接口文档-前端使用指南.md#路线优化)
- [行程优化算法集成](./trail-integration-guide.md#行程优化算法集成)

