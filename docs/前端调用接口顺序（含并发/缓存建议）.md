0) App 启动与全局（每次进入 App / 切换账号）

系统能力探测（决定哪些按钮可用、用哪个 provider）

GET /system/status

（可选）预热：常用配置/字典（如果你有）

GET /llm/providers

GET /transport/provider-status

前端策略：把 system/status 缓存 30~60s；provider degraded 时 UI 显示“可能使用估算/降级”。

1) 创建行程（表单创建：Story 1.1）

用户点「新建行程」→ 填表 → 创建成功进详情页

POST /trips（创建 Trip）

跳转行程详情页后，并发拉取：

GET /trips/:id（Trip + days + items 基础数据）

（可选）GET /trips/:id/progress?now=...（如果你在详情页就显示“当前/下一站”）

说明：你现在的 stories 里“创建后自动推荐酒店/节奏策略/预算切分”都可以直接作为 POST /trips 的响应字段返回，避免多打一次接口。

2) 自然语言创建行程（Story 1.2 + LLM 14.1/14.4）

用户在首页输入：“帮我带娃去东京5天预算2万”

POST /llm/parse-trip

若返回 need_clarification：
2. 前端展示澄清问题表单（或对话）
3. 用户补充后 再次 POST /llm/parse-trip（带补充信息 / 或前端合并成 params）

拿到 params 后：POST /trips

进入详情页：同「创建行程」第 2 步（并发 GET /trips/:id 等）

前端提示：LLM 解析成功后，把解析出的字段回填到表单，让用户“一眼确认”。

3) 行程详情页首次加载（Story 1.3）

进入 Trip Detail（时间轴/地图/统计）

GET /trips/:id（主数据：Trip + Days + Items）

并发（按你 UI 组件需要选用）：

GET /trips/:id/progress?now=...（顶部“下一站”卡片）

若列表中需要 Place 卡片详情（名称/地址/营业状态）：

方案 A：后端在 GET /trips/:id 里直接嵌入 place snapshot（推荐）

方案 B：前端按 place_id 批量拉（如果你有批量接口；没有的话别 N+1）

前端策略：GET /trips/:id 是唯一真源；后续所有动作成功后都以返回的 schedule 更新本地 store，尽量别立刻再 GET 全量。

4) 搜索地点 → 加入行程（Places 2.1 + Items 3.1）

用户搜“东京塔”→ 选一个 → 加入 Day2

搜索：

GET /places/search?q=东京塔&types=...&lat=...&lng=...

用户点“加入行程”：

POST /trips/:id/items

成功后：

用响应里的 item 更新时间轴（不必立刻 GET /trips/:id）

若返回 violations（warning/info）则在 UI 显示黄色提示

5) 调整活动时间（拖拽）→（可选）局部重算（Items 3.2 + Actions/Optimization）
5.1 简单拖拽修改（只改一个 item）

PATCH /items/:id（后端校验营业时间/冲突）

若返回 409 TIME_CONFLICT：

前端提示“冲突”，给两个入口：

“仍要这样放”（如果你允许写入后再修复）

“帮我修复/重排”（走 5.2）

5.2 需要系统帮你“修复/重排”（推荐走 Action Preview）

POST /actions/preview（action_type=RESCHEDULE_AROUND_ITEM / MOVE_ITEM_TO_TIME）

前端展示 diff（影响范围、删除/移动项、警告）

用户确认：POST /actions/apply

用返回的新 schedule 更新 UI（并显示 explain）

6) 日内优化（用户点「优化路线」：Optimization 4.x）

用户选了多个点 → 点“优化路线”

（可选）先评估稳健度：

POST /policy/evaluate（让用户知道“目前风险/最紧张点”）

执行优化：

POST /optimize/day（返回 schedule + dropped_items + violations + explain）

前端展示优化结果：

dropped_items（必须展示“为什么”）

explain（为什么这样排）

用户确认写入（两种实现选一）：

方案 A：优化接口直接落库（前端只更新 store）

方案 B：优化结果先预览，确认后落库（推荐一致性）

你可以用：POST /actions/apply（action_type=APPLY_OPTIMIZED_SCHEDULE）

你的 Story 4.5 强调解释性：前端一定要给“为什么这样排 / 为什么没安排”的入口，直接用 dropped_items.explain 渲染即可。

7) 行程项之间交通展示（Transport 5.1/5.3）

用户点开某两个相邻点之间的“交通条”

POST /transport/plan

前端展示：

多 options（walk/transit/taxi…）

t_robust_range 或 “预计到达（含缓冲）”

pain_index + 推荐理由

性能建议：交通方案按 “(from_item_id,to_item_id,departure_time_bucket)” 做缓存；同一段不要重复算。

8) What-If 评估（PlanningPolicy 6.3/6.4/6.5）

用户点“更稳一点/更松一点/少一个点试试”

分步体验（你 story 6.4）：

POST /policy/evaluate（先给 base 风险）

POST /policy/suggest（生成候选方案列表，不跑 MC）

用户选择某个候选：

POST /policy/whatif/run（对选中的候选跑评估）

返回对比与 winnerId：

前端展示“原计划 vs 候选”

用户点“应用该方案”：

POST /policy/apply

（可选）“一键复评”：

POST /policy/whatif/run（higher samples）

9) 行程进行中：下一站（Trips 1.4 + Actions Query）

用户问“下一站是哪里？”（按钮/语音都一样）

推荐统一走 Action（因为它不改数据）：

POST /actions/apply（action_type=QUERY_NEXT_STOP）或你也可以走只读 GET /trips/:id/progress

前端展示 next stop + ETA（含缓冲）

若用户点“导航/叫车”再走外部 deep link（前端侧）

10) 语音控制（Voice 11.1/11.3 → ScheduleAction 13.x）

用户说“把东京塔移到上午”

POST /voice/transcribe（语音→文字）

POST /voice/parse-intent（文字→ action_type + payload）

POST /actions/preview

用户确认：POST /actions/apply

11) 拍照识别 POI（Vision 12.2 → Places/Items）

用户拍菜单/招牌 → 推荐地点 → 加入行程

POST /vision/ocr-poi（返回候选 places + why）

用户选一个：

POST /trips/:id/items（加入行程）

（可选）加入后提示“是否优化当天”：

POST /optimize/day 或 POST /actions/preview

12) 分享与导入（Trips 1.6）

分享

POST /trips/:id/share（你后端需要补这个接口）

得到 share_token，生成链接

导入

POST /trips/import（token → 新 trip_id）

跳转详情页：GET /trips/:id

13) 复盘报告（Trips 1.5）

POST /trips/:id/recap

若是同步返回：直接展示
若返回 job_id：前端轮询

GET /trips/:id/recap/:job_id

一张“总览顺序图”（最常用的主干）

创建 → 详情 → 加点 → 优化 → 应用 → 交通 → 下一站

POST /trips

GET /trips/:id

GET /places/search → POST /trips/:id/items

POST /optimize/day → POST /actions/apply (APPLY_OPTIMIZED_SCHEDULE)

POST /transport/plan（按需）

GET /trips/:id/progress 或 POST /actions/apply (QUERY_NEXT_STOP)